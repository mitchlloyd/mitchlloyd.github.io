---
layout: post
title:  "Still Programing Part 1: Making Programming Easy Enough for Everyone"
date:   2015-11-01 19:28:35 -0800
---

When I was a junior in high-school, adults asked me what I wanted to do for a
living. I spent my free time making music and programming computer games but my
parents were not satisfied with either of these activities as career
aspirations.

Programming, according to the wisdom of 1998, would soon to be outsourced to
countries with emerging economies like India, China and Russia.  Programing
was a poor choice of profession for someone living in the United States.

"It really is very mundane," a teacher told me. "You could be someone that
_manages_ developers, but you don't want to actually be writing code."

I want to believe this attitude toward programming has changed, but in my career
I've still found people that believe the value of a manager is always greater
than the value of a programmer. This misunderstanding beings when one equates
management with leadership and programming with grunt work.

In this series of posts I'll describe the nature of computer programming to
people that have an interest in it, but not extensive experience.  I want to
explain why programming will not be cheaply outsourced, automated away, or
suddenly become obsolete. I'll argue that Programmer can be a leveraged position
for an employee.

Programming in Plain English
----------------------------

Throughout its short history, people tried to eliminate programming by
changing the esoteric code used for programming. Instead of programming in
Java, C++, Fortran, or Python why don't we program in English?

Programming languages are not intended to obscure what programmers are doing.
They are earnest attempts to let humans express solutions as clearly and simply
as possible.  If programmers could program effectively in in their spoken
languages they would. Unfortunately, spoken language is too verbose and
ambiguous to effectively describe technical problems.

Here is a programming expression in COBOL, a language designed to read like English:

```
X IS GREATER THAN Y
```

That seems fine. Here is that expression in Ruby, C, Java, Python, and many
other languages. This is also a valid expression in COBOL:

```
x > y
```

You probably already understand that code because you likely have some
experience with math notation. Mathematicians also uses symbolic language to
express problems and solutions.

Here is a math problem expressed in English.

> Take one and two and add them together. Now take ten and subtract eight from it.
> Take the first result from adding one and two and multiply it by the second
> result that you got from subtracting ten from eight.

Now here is that same problem in many programming languages:

```
(1 + 2) * (10 - 8)
```

Hopefully you can see that even simple problems can be awkward to express in
English.  Imagine needing to read a page of text to understand something that a
programmer could quickly understand by reading just a few lines of code.
Programming languages are better suited for solving problems with logic and data
than English. This is why they exist.


Programming With Visual Tools
-----------------------------
Another argument for the demise of programming is that an easy-to-use visual
tool will make the job simple enough for everyone to do, eliminating programming
as a profession.

Modern programmers already use many visual tools as they program. They have
tests that show alerts when something is wrong.  They have text editors
that complete code for them and have sophisticated ways of showing errors as
they type. There are tools like Xcode and Visual Studio Code that have drag and
drop interfaces. Look at a programmer's screen as they work and you'll see
a myriad of colors, signals, shapes, and diagrams giving them information.

Programming is not challenging because of archaic tools. Rather, programmers
have some of the most sophisticated tools that you'll find.  User interfaces
that primarily rely on a mouse or finger for input can be easier to use because
the input that a user can provide at any time is very constrained.  If you see a
box that says "Save or Delete?" with two buttons, you know exactly what you can
do.  When programming there are no practical limits on what the developer is
allowed to do at any given moment. Similarly, when composing an email, users
could write messages by scrolling through a list of possible words and choosing
them one at a time, but it's well worth their time to learn to type instead.

We _have_ created programming interfaces for casual users -- most notably
[spreadsheet programs like Excel](http://c2.com/cgi/wiki?MicrosoftExcelProgrammingLanguage).
With just a little training, a user can transform data in interesting ways and
even create their own user interfaces.

A single spreadsheet user can perform the work of a thousand or more that lack
the same tool. However, to continue tackling bigger problems users must spend
years learning learning to use pivot tables, formulas, and eventually the VBA
programming language.  Although spreadsheet applications are optimized for
simple use cases, advanced users can program with them.

The means by which programmers input their ideas into a computer is completely
incidental to the task of programming.  Most programmers type and use mouses. A
programmer with hand disabilities may use their feet to augment their input or
use an application that can translate voice into text. No form of input is any
more or less emblematic of programming.

If you want some thoughtful discussion about the future of human-computer
interaction for programmers I suggest you read and watch the work of [Bret
Victor](worrydream.com). Specifically [Seeing
Spaces](http://worrydream.com/SeeingSpaces/) is relevant to this discussion.
But no matter what medium we use to build programs, it is the ideas and logic
that we describe -- not the medium -- that have value.

Typing words into a computer is as incidental to programming as talking on the
phone is for a CEO. Neither activity defines the job.
